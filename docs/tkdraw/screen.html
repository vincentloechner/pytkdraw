<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tkdraw.screen API documentation</title>
<meta name="description" content="Basic draw graphical user interface (GUI) based on tkinter, synchroneous â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tkdraw.screen</code></h1>
</header>
<section id="section-intro">
<p>Basic draw graphical user interface (GUI) based on tkinter, synchroneous.</p>
<p>Test this module using <code>python3 -m tkdraw.screen</code></p>
<p>The online documentation is available under python3:</p>
<pre><code>$ python3
&gt;&gt;&gt; import tkdraw.screen as tkd
&gt;&gt;&gt; help(tkd.open)
or
&gt;&gt;&gt; help(tkd.open.FUNC_NAME)
</code></pre>
<p>Copyright 2018-2021, Vincent Loechner.
Distributed under the MIT license (see LICENSE)
<a href="https://github.com/vincentloechner/pytkdraw.git">https://github.com/vincentloechner/pytkdraw.git</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Basic draw graphical user interface (GUI) based on tkinter, synchroneous.

Test this module using `python3 -m tkdraw.screen`

The online documentation is available under python3:
```
$ python3
&gt;&gt;&gt; import tkdraw.screen as tkd
&gt;&gt;&gt; help(tkd.open)
or
&gt;&gt;&gt; help(tkd.open.FUNC_NAME)
```

Copyright 2018-2021, Vincent Loechner.
Distributed under the MIT license (see LICENSE)
https://github.com/vincentloechner/pytkdraw.git
&#34;&#34;&#34;

import tkinter as tk
import queue


class open(tk.Canvas):
    &#34;&#34;&#34;Main class for a window containing a board (2D grid).

    The 2D grid is pythonesque: always starts at top-left position (0, 0), in
    row-major order, ends at (height-1, width-1) included. All coordinates and
    sizes are expressed as iterable objects (a tuple or a list for example) of
    two integers.

    To open a window containing just an array of pixels, set the `pixels`
    parameter to 1 and `grid` to False.
    This class inherits from tkinter&#39;s canvas class.

    Example:
        ```
        import tkdraw.screen
        g = tkdraw.screen.open()
        g.message(&#34;hello&#34;)
        g.wait_event()
        g.close()
        ```
    Args:
        size ([int, int]): a couple (height, width) specifying the size of
            the grid (default: (8, 8))
        pixels (int): number of pixels of a square (default: 100)
        grid (bool): if True, prints a one-pixel grid to separate the tiles:
            horizontal and vertical lines (default: True) - the real size of
            the window is also increased by one pixel to draw the right/bottom
            lines


    Returns:
        The window object.

    Notes:
        Since this class inherits from tkinter&#39;s canvas class, more inherited
            documentation will be displayed below this paragraph. You can
            directly call the canvas methods to perform advanced drawings in
            this canvas (expert mode, be warned that a couple of coordinates
            (y, x) in tkdraw has to be transformed into two integers x+1, y+1
            in tkinter). You may refer to the documentation of tkinter
            describing the Canvas widget here:
            &lt;https://docs.python.org/3/library/tkinter.html&gt;
    &#34;&#34;&#34;

    def __init__(
        self, size=(8, 8), pixels=100, grid=True
    ):
        # some private methods below, to react to asynchronous events:

        # private: the user clicked on a square
        def _click(evenement):
            # min to handle user clicking on the last pixel:
            i = min((evenement.y-1)//self.pixels, self.size[0]-1)
            j = min((evenement.x-1)//self.pixels, self.size[1]-1)
            # add the event (line, column) to the queue
            self.eventq.put((&#34;click&#34;, (i, j)))
            # and leave the mainloop
            self.root.quit()

        # private: the user hit a key
        def _key(evenement):
            # put the event in the queue
            self.eventq.put((&#34;key&#34;, evenement.keysym))
            # and leave the mainloop
            self.root.quit()

        # private: the user closed the window
        def _async_end():
            # put the END event in the queue
            self.eventq.put((&#34;END&#34;, None))
            # and close
            self.close()

        # private: regularily check if some events are pending in the queue
        # and wake up
        def _checke():
            self.after_id = self.root.after(1000, _checke)
            # stop mainloop
            self.root.quit()

        #################################
        # INIT
        self.size = size
        self.pixels = pixels
        self.root = None
        self.after_id = None
        self.gap = int(grid)  # 1 more pixel if grid is True

        self.eventq = queue.Queue()

        self.root = tk.Tk()
        # you can create other widgets here if you want to
        # self.frame = tk.Frame(root)

        # creates THE canvas:
        tk.Canvas.__init__(
                self,
                self.root,
                height=self.size[0]*self.pixels+self.gap,
                width=self.size[1]*self.pixels+self.gap,
                background=&#34;#ddd&#34;,
                takefocus=True,
                borderwidth=0,
                highlightthickness=1)
        self.pack()
        # self.place(relx=0.5, rely=0.5, anchor=tk.CENTER)
        self.focus_set()

        # binds the click function to the click event
        self.bind(&#34;&lt;Button-1&gt;&#34;, _click)
        # binds the key function to the keypress event
        self.bind(&#34;&lt;Any-KeyPress&gt;&#34;, _key)

        # checke will be called once per second
        self.after_id = self.root.after(1000, _checke)
        # ensure that async_end is called if the window is killed
        self.root.protocol(&#34;WM_DELETE_WINDOW&#34;, _async_end)

        # draw the original state
        if grid:
            self.draw_grid()

    def __enter__(self):
        &#34;&#34;&#34;Internal: With -as: statement compatibility.&#34;&#34;&#34;
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34;Internal: With -as: statement compatibility.&#34;&#34;&#34;
        self.close()

    def __del__(self):
        &#34;&#34;&#34;Internal: if the object is freeed by python for some reason.&#34;&#34;&#34;
        self.close()

    def close(self):
        &#34;&#34;&#34;Close this window.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        if self.after_id is not None:
            self.root.after_cancel(self.after_id)
            self.after_id = None
        if self.root is not None:
            self.root.destroy()
            self.root = None

    def message(self, message):
        &#34;&#34;&#34;Display a message in a box and wait for the user to click somewhere.

        Args:
            message (str): the string to print

        Returns:
            bool: True if the user triggered a normal event, False if the user
                closed the window abruptly.
        &#34;&#34;&#34;
        # private: the user clicked in the box
        def _c(event):
            self.eventq.put(&#34;ok&#34;)
            self.root.quit()

        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)
        m = tk.Message(
                self.root, text=message,
                padx=20, pady=20,
                relief=tk.RAISED, borderwidth=5,
                )
        # mouse click:
        m.bind(&#34;&lt;Button-1&gt;&#34;, _c)
        # m.grid(row=0, column=0)
        m.place(relx=0.5, rely=0.5, anchor=tk.CENTER)
        while True:
            s = self.wait_event()
            if s[0] == &#34;END&#34;:
                # the window has been closed
                # put the end msg back in the queue and return False
                self.eventq.put(s)
                return False
            # all the other events just close the message box and return True:
            m.destroy()
            return True

    ###########################################################################
    # HIGH LEVEL INTERFACE                                                    #
    # This function can be used to print whole standard boards.               #
    # Matrices should contain integers (-&gt; representing pieces colors/players)#
    # or the None special value (-&gt; nothing there)                            #
    ###########################################################################

    # by default define those 10 colors:
    DEFAULT_COLOR = [&#34;black&#34;, &#34;white&#34;, &#34;red&#34;, &#34;green&#34;, &#34;blue&#34;,
                     &#34;yellow&#34;, &#34;cyan&#34;, &#34;magenta&#34;, &#34;orange&#34;, &#34;darkgrey&#34;]
    &#34;&#34;&#34;A list of ten colors (str) used for ten players identified by numbers.&#34;&#34;&#34;

    def draw_grid(
        self, matrix=None, grid=True
    ):
        &#34;&#34;&#34;Print a complete grid of pieces, using the 10 default colors.

        Args:
            matrix (list of list of int): the players pieces matrix, of the
                specified size. If matrix is None (default), just ignores it.
            grid (boolean): if True (default) draws a horizontal+vertical grid
                to separate the tiles.

        Returns:
            list of int: the graphical objects that were created for the pieces
                (grid excluded).
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)
        # erase everything for a start
        self.delete(tk.ALL)
        # gap is used by draw_tile to fill the inside of a tile (including
        # borders, or not
        if grid:
            for i in range(self.size[0]+self.gap):
                self.create_line(1, i*self.pixels+1,
                                 self.size[1]*self.pixels+1, i*self.pixels+1,
                                 width=1)
            for i in range(self.size[1]+self.gap):
                self.create_line(i*self.pixels+1, 1,
                                 i*self.pixels+1,
                                 self.size[0]*self.pixels+1+self.gap,
                                 width=1)
        # draw the pieces
        o = []
        if matrix is not None:
            for i in range(self.size[0]):
                for j in range(self.size[1]):
                    if matrix[i][j] is not None:
                        o.append(self.draw_piece((i, j), matrix[i][j],
                                 refresh=False))
        # update just once at the end, for performance
        self.update()
        return o

    def erase(
        self
    ):
        &#34;&#34;&#34;Erase everything from the window.

        All graphical objects that were created are deleted.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)
        self.delete(tk.ALL)
        # redraw the grid if it was there:
        if self.gap == 1:
            self.draw_grid()

    ###########################################################################
    # INTERMEDIATE LEVEL INTERFACE                                            #
    # draw various objects on a board (2D grid)                               #
    ###########################################################################
    def draw_piece(
        self, p, player=0,
        color=None,
        refresh=True
    ):
        &#34;&#34;&#34;Draw a piece in position p=(line, column), player-colored.

        Usage notice: don&#39;t use this function if your tiles are too small, you
        won&#39;t see the piece.

        Args:
            p ([int, int]): a couple (line, column) specifying the grid
                position. (0, 0) = top-left position.
            player (int, optional): player number (default: 0)
                player is used only if color is NOT given.
            color (str, optional): fill color of the piece. If a color is
                given, player is ignored.
            refresh (bool): refresh the window after drawing (default: True)

        Returns:
            int: the ID of the graphical object (circle) that was created.
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)
        if color is None:
            if isinstance(player, int):
                color = self.DEFAULT_COLOR[player % len(self.DEFAULT_COLOR)]
            else:
                color = self.DEFAULT_COLOR[0]

        bord = self.pixels//10+1
        i, j = p
        if not (0 &lt;= i &lt; self.size[0] and 0 &lt;= j &lt; self.size[1]):
            raise ValueError(&#34;trying to draw outside the window!&#34;)

        o = self.create_oval(j*self.pixels+bord+1,
                             i*self.pixels+bord+1,
                             (j+1)*self.pixels-bord+1,
                             (i+1)*self.pixels-bord+1,
                             width=1, fill=color)
        if refresh:
            self.update()
        return o

    def move_piece(
        self, obj, pos, refresh=True
    ):
        &#34;&#34;&#34;Move a piece (obj ID) in grid position pos (couple).

        Args:
            obj (int): a previously created piece ID
            pos ([int, int]): new grid position, a couple (line, column)
            refresh (bool, optional): refresh the window after drawing
                (default: True)

        Returns:
            None
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        i, j = pos
        if not (0 &lt;= i &lt; self.size[0] and 0 &lt;= j &lt; self.size[1]):
            raise ValueError(&#34;trying to move a piece outside the window!&#34;)
        bord = self.pixels//10+1
        self.coords(
            obj,
            j*self.pixels+bord+1,
            i*self.pixels+bord+1,
            (j+1)*self.pixels-bord+1,
            (i+1)*self.pixels-bord+1
            )
        if refresh:
            self.update()

    def draw_tile(
        self, p,
        color=&#34;black&#34;,
        border=0,
        refresh=True
    ):
        &#34;&#34;&#34;Fill the inside of a tile in position p=(line, column) with a color.

        Args:
            p ([int, int]): grid position (line, column)
            color (str, optional): color of the tile (default: &#34;black&#34;)
            border (int, optional): border thickness (default: 0) - borders may
                overlap over neighboring tiles
            refresh (bool): refresh the window after drawing (default: True)

        Returns:
            int: the ID of the colored tile
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        i, j = p
        if not (0 &lt;= i &lt; self.size[0] and 0 &lt;= j &lt; self.size[1]):
            raise ValueError(&#34;trying to fill a tile outside the window!&#34;)

        o = self.create_rectangle(j*self.pixels+1+self.gap,
                                  i*self.pixels+1+self.gap,
                                  (j+1)*self.pixels+1,
                                  (i+1)*self.pixels+1,
                                  width=border, fill=color)
        if refresh:
            self.update()
        return o

    def move_tile(
        self, obj, pos, refresh=True
    ):
        &#34;&#34;&#34;Move a colored tile to another grid position.

        Args:
            obj (int): a previously created tile ID
            pos ([int, int]): new position in the grid (line, column)
            refresh (bool, optional): refresh the window after drawing
                (default: True)

        Returns:
            None
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        i, j = pos
        if not (0 &lt;= i &lt; self.size[0] and 0 &lt;= j &lt; self.size[1]):
            raise ValueError(&#34;trying to move a tile outside the window!&#34;)
        self.coords(
            obj,
            j*self.pixels+1++self.gap,
            i*self.pixels+1++self.gap,
            (j+1)*self.pixels+1,
            (i+1)*self.pixels+1
            )
        if refresh:
            self.update()

    ###########################################################################
    # low level interface:                                                    #
    # draw pixels, lines, circles, etc.                                       #
    ###########################################################################
    def draw_line(
        self, x1, x2, color=&#34;black&#34;, thickness=1, refresh=True
    ):
        &#34;&#34;&#34;Draw a line between x1=(l1, c1) and x2=(l2, c2) (excluded).

        Args:
            x1 ([int, int]): pixel-wise positions (line, column) of the first
                point. (0,0) = top-left position.
            x2 ([int, int]): pixel-wise positions (line, column) of the second
                point, excluded.
            color (str, optional): line color (default: &#34;black&#34;)
            thickness (int, optional): thickness of the line (default: 1)
            refresh (bool, optional): refresh the window after drawing
                (default: True)

        Returns:
            int: the ID of the graphical object that was created.
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        o = self.create_line(x1[1]+1, x1[0]+1, x2[1], x2[0],
                             width=thickness, fill=color)
        if refresh:
            self.update()
        return o

    def draw_circle(
        self, x1, x2,
        color=&#34;black&#34;, border=1, refresh=True
    ):
        &#34;&#34;&#34;Draw a circle in the bounding box of x1=(l1,c1) and x2 (excluded).

        Args:
            x1 ([int, int]): pixel-wise positions (line, column) of the first
                point. (0,0) = top-left position.
            x2 ([int, int]): pixel-wise positions (line, column) of the second
                point, excluded.
            color (str, optional): color of the inside (default: &#34;black&#34;)
                       if color == None, don&#39;t fill the circle.
            border (int, optional): border thickness (default: 1) - borders can
                overflow over the given pixels coordinates
            refresh (bool, optional): refresh the window after drawing
                (default: True)

        Returns:
            int: the ID of the graphical object that was created.
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        o = self.create_oval(x1[1]+1, x1[0]+1, x2[1], x2[0],
                             width=border, fill=color)
        if refresh:
            self.update()
        return o

    def draw_text(
        self, position, text,
        color=&#34;black&#34;, fontname=&#34;Purisa&#34;, fontsize=11, refresh=True
    ):
        &#34;&#34;&#34;Draw a text centered at a given position=(line, column).

        Args:
            position ([int, int]): pixel-wise position (line, column).
                (0,0) = top-left position.
            text (str): text to print
            color (str, optional): text color (default: &#34;black&#34;)
            fontname (str, optional): font name (default: &#34;Purisa&#34;)
            fontsize (int, optional): font size (default: 11pt)
            refresh (bool, optional): refresh the window after drawing
                (default: True)

        Returns:
            int: the ID of the graphical object that was created.
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        o = self.create_text(position[1]+1, position[0]+1,
                             text=text,
                             font=(fontname, fontsize),
                             fill=color)
        if refresh:
            self.update()
        return o

    def bg(
        self, obj, before=1, refresh=True
    ):
        &#34;&#34;&#34;Send a graphical object (ID) to the background.

        Args:
            obj (int): object ID returned by an object creation method
            before (int, optional): the object behind which to hide (default:
                1 = all)
            refresh (bool, optional): refresh the window after drawing
                (default: True)

        Returns:
            None
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)
        # se met en fond, derriÃ¨re l&#39;objet &#39;before&#39;:
        self.tag_lower(obj, before)
        if refresh:
            self.update()

    def refresh(
        self
    ):
        &#34;&#34;&#34;Refresh all objects previously drawn in the window.

        Note:
            You can create several successive objects without refreshing by
                passing the extra argument &#34;refresh=False&#34; to the drawing
                functions, and then refresh only once using this function.
                Good for speed, especially if you draw many things.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        self.update()

    def rm(
        self, obj, refresh=True
    ):
        &#34;&#34;&#34;Delete a graphical object (ID).

        Args:
            obj (int): an object ID (returned by an object creation method)
            refresh (bool, optional): refresh the window after drawing
                (default: True)

        Returns:
            None
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        self.delete(obj)
        if refresh:
            self.update()

    ###########################################################################
    # Main I/O function                                                       #
    ###########################################################################
    def wait_event(self, delay=None):
        &#34;&#34;&#34;Wait for the user to interact with the window.

        The tracked events are only keypress and mouse click (left button).

        Args:
            delay (int, optional): waiting time in ms (default: wait forever)

        Returns:
            If the delay expires (when given)

            - `None`

            Else, returns a couple, the first element being always a string:

            - `(&#34;click&#34;, (line, column))`

                if the user clicks on a tile of the board, where (line, column)
                    are the integer coordinates of the clicked tile

            - `(&#34;key&#34;, letter)`

                if the user hits a key, where letter is a string containing a
                    description of the key. If you&#39;re looking for a specific
                    key, you can give a try to the demo - running
                    `&#39;python3 -m tkdraw&#39;` will print all occuring events in the
                    console

            - `(&#34;END&#34;, None)`

                if the user closes the window
        &#34;&#34;&#34;
        # private: called when the timer expires
        def delay_expire():
            self.eventq.put(None)
            self.idd = None
            self.root.quit()

        # trigger the timer
        self.idd = None
        if delay is not None:
            if not self.root:
                raise InterruptedError(&#34;window killed&#34;)
            self.idd = self.root.after(delay, delay_expire)
        # This is Tk&#39;s main loop
        # checks the events and get out if something happens
        while True:
            ####################
            try:
                # get something from the event queue
                r = self.eventq.get(False)
                # cancels the timer if I got something
                if self.idd is not None and self.root is not None:
                    self.root.after_cancel(self.idd)
                return r
            except queue.Empty:
                # no event in the queue, continue waiting (go to mainloop)
                pass
            ####################
            if not self.root:
                raise InterruptedError(&#34;window killed&#34;)
            # back to the mainloop, it will stop if I get an event
            self.root.mainloop()
            ####################

    def mouse_position(self):
        &#34;&#34;&#34;Return the mouse position (pixel-wise).

        Note:
            The returned coordinates can be negative or greater than the window
                size, when the mouse is out of the window but the window still
                selected.

        Args:
            None

        Returns:
        - a couple ([int, int]): pixel-wise position (line, column) relative to
          (0,0) = top-left position in the window.
        &#34;&#34;&#34;
        # private: the mouse moved
        def _motion(event):
            self.souris = (event.y, event.x)

        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)
        self.refresh()
        try:
            return self.souris
        except AttributeError:
            self.bind(&#34;&lt;Motion&gt;&#34;, _motion)
            self.souris = (0, 0)  # initial position if the mouse doesn&#39;t move
            return self.souris


###########################################################################
# Test program: 8x8 board, click to place/remove black/white pieces       #
###########################################################################
if __name__ == &#34;__main__&#34;:
    # open the window containing a board
    SIZE = 8
    PIXEL_SIZE = 100
    # use tkdraw.screen.open() if you include this as a module with
    # &#39;import tkdraw.screen&#39;
    g = open((SIZE, SIZE), PIXEL_SIZE)

    # checkered tiles:
    for i in range(SIZE):
        for j in range(i % 2, SIZE, 2):
            g.draw_tile((i, j), color=&#34;yellow&#34;, refresh=False)
    # refresh only once for performance
    g.refresh()

    # welcome message
    msg = g.draw_text((PIXEL_SIZE//2, PIXEL_SIZE+PIXEL_SIZE//2),
                      &#34;Hello!\nclick here -&gt;&#34;)

    # main loop: wait for user clicks and draw pieces.
    # tab = 2D grid containing the graphical object IDs
    # if you click again on a piece it will be deleted, same player plays
    tab = [[None]*SIZE for i in range(SIZE)]
    player = 1  # white player starts, black = -1.
    while True:
        p = g.wait_event()
        # demo: print the content of the event couple
        print(p)

        # stop when:
        if p[0] == &#34;END&#34;:
            break
        # or when:
        if p[0] == &#34;key&#34; and p[1] in [&#34;q&#34;, &#34;Q&#34;, &#34;Escape&#34;]:
            break

        # ignore all events other than mouse click
        if p[0] != &#34;click&#34;:
            continue

        lig, col = p[1]
        if tab[lig][col] is None:
            tab[lig][col] = g.draw_piece(p[1], player)
            # player : 1 -&gt; -1 -&gt; 1 -&gt; ...
            player = -player
        else:
            # remove the piece at position (lig, col)
            g.rm(tab[lig][col])
            tab[lig][col] = None

        # remove the previous message
        g.rm(msg)
        # and put a new one
        msg = g.draw_text((PIXEL_SIZE//2, PIXEL_SIZE+PIXEL_SIZE//2),
                          [0, &#34;white player&#34;, &#34;black player&#34;][player])

    # at the end, close the window properly
    g.close()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tkdraw.screen.open"><code class="flex name class">
<span>class <span class="ident">open</span></span>
<span>(</span><span>size=(8, 8), pixels=100, grid=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Main class for a window containing a board (2D grid).</p>
<p>The 2D grid is pythonesque: always starts at top-left position (0, 0), in
row-major order, ends at (height-1, width-1) included. All coordinates and
sizes are expressed as iterable objects (a tuple or a list for example) of
two integers.</p>
<p>To open a window containing just an array of pixels, set the <code>pixels</code>
parameter to 1 and <code>grid</code> to False.
This class inherits from tkinter's canvas class.</p>
<h2 id="example">Example</h2>
<pre><code>import tkdraw.screen
g = tkdraw.screen.open()
g.message(&quot;hello&quot;)
g.wait_event()
g.close()
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong> :&ensp;<code>[int, int]</code></dt>
<dd>a couple (height, width) specifying the size of
the grid (default: (8, 8))</dd>
<dt><strong><code>pixels</code></strong> :&ensp;<code>int</code></dt>
<dd>number of pixels of a square (default: 100)</dd>
<dt><strong><code>grid</code></strong> :&ensp;<code>bool</code></dt>
<dd>if True, prints a one-pixel grid to separate the tiles:
horizontal and vertical lines (default: True) - the real size of
the window is also increased by one pixel to draw the right/bottom
lines</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The window object.</p>
<h2 id="notes">Notes</h2>
<p>Since this class inherits from tkinter's canvas class, more inherited
documentation will be displayed below this paragraph. You can
directly call the canvas methods to perform advanced drawings in
this canvas (expert mode, be warned that a couple of coordinates
(y, x) in tkdraw has to be transformed into two integers x+1, y+1
in tkinter). You may refer to the documentation of tkinter
describing the Canvas widget here:
<a href="https://docs.python.org/3/library/tkinter.html">https://docs.python.org/3/library/tkinter.html</a></p>
<p>Construct a canvas widget with the parent MASTER.</p>
<p>Valid resource names: background, bd, bg, borderwidth, closeenough,
confine, cursor, height, highlightbackground, highlightcolor,
highlightthickness, insertbackground, insertborderwidth,
insertofftime, insertontime, insertwidth, offset, relief,
scrollregion, selectbackground, selectborderwidth, selectforeground,
state, takefocus, width, xscrollcommand, xscrollincrement,
yscrollcommand, yscrollincrement.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class open(tk.Canvas):
    &#34;&#34;&#34;Main class for a window containing a board (2D grid).

    The 2D grid is pythonesque: always starts at top-left position (0, 0), in
    row-major order, ends at (height-1, width-1) included. All coordinates and
    sizes are expressed as iterable objects (a tuple or a list for example) of
    two integers.

    To open a window containing just an array of pixels, set the `pixels`
    parameter to 1 and `grid` to False.
    This class inherits from tkinter&#39;s canvas class.

    Example:
        ```
        import tkdraw.screen
        g = tkdraw.screen.open()
        g.message(&#34;hello&#34;)
        g.wait_event()
        g.close()
        ```
    Args:
        size ([int, int]): a couple (height, width) specifying the size of
            the grid (default: (8, 8))
        pixels (int): number of pixels of a square (default: 100)
        grid (bool): if True, prints a one-pixel grid to separate the tiles:
            horizontal and vertical lines (default: True) - the real size of
            the window is also increased by one pixel to draw the right/bottom
            lines


    Returns:
        The window object.

    Notes:
        Since this class inherits from tkinter&#39;s canvas class, more inherited
            documentation will be displayed below this paragraph. You can
            directly call the canvas methods to perform advanced drawings in
            this canvas (expert mode, be warned that a couple of coordinates
            (y, x) in tkdraw has to be transformed into two integers x+1, y+1
            in tkinter). You may refer to the documentation of tkinter
            describing the Canvas widget here:
            &lt;https://docs.python.org/3/library/tkinter.html&gt;
    &#34;&#34;&#34;

    def __init__(
        self, size=(8, 8), pixels=100, grid=True
    ):
        # some private methods below, to react to asynchronous events:

        # private: the user clicked on a square
        def _click(evenement):
            # min to handle user clicking on the last pixel:
            i = min((evenement.y-1)//self.pixels, self.size[0]-1)
            j = min((evenement.x-1)//self.pixels, self.size[1]-1)
            # add the event (line, column) to the queue
            self.eventq.put((&#34;click&#34;, (i, j)))
            # and leave the mainloop
            self.root.quit()

        # private: the user hit a key
        def _key(evenement):
            # put the event in the queue
            self.eventq.put((&#34;key&#34;, evenement.keysym))
            # and leave the mainloop
            self.root.quit()

        # private: the user closed the window
        def _async_end():
            # put the END event in the queue
            self.eventq.put((&#34;END&#34;, None))
            # and close
            self.close()

        # private: regularily check if some events are pending in the queue
        # and wake up
        def _checke():
            self.after_id = self.root.after(1000, _checke)
            # stop mainloop
            self.root.quit()

        #################################
        # INIT
        self.size = size
        self.pixels = pixels
        self.root = None
        self.after_id = None
        self.gap = int(grid)  # 1 more pixel if grid is True

        self.eventq = queue.Queue()

        self.root = tk.Tk()
        # you can create other widgets here if you want to
        # self.frame = tk.Frame(root)

        # creates THE canvas:
        tk.Canvas.__init__(
                self,
                self.root,
                height=self.size[0]*self.pixels+self.gap,
                width=self.size[1]*self.pixels+self.gap,
                background=&#34;#ddd&#34;,
                takefocus=True,
                borderwidth=0,
                highlightthickness=1)
        self.pack()
        # self.place(relx=0.5, rely=0.5, anchor=tk.CENTER)
        self.focus_set()

        # binds the click function to the click event
        self.bind(&#34;&lt;Button-1&gt;&#34;, _click)
        # binds the key function to the keypress event
        self.bind(&#34;&lt;Any-KeyPress&gt;&#34;, _key)

        # checke will be called once per second
        self.after_id = self.root.after(1000, _checke)
        # ensure that async_end is called if the window is killed
        self.root.protocol(&#34;WM_DELETE_WINDOW&#34;, _async_end)

        # draw the original state
        if grid:
            self.draw_grid()

    def __enter__(self):
        &#34;&#34;&#34;Internal: With -as: statement compatibility.&#34;&#34;&#34;
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        &#34;&#34;&#34;Internal: With -as: statement compatibility.&#34;&#34;&#34;
        self.close()

    def __del__(self):
        &#34;&#34;&#34;Internal: if the object is freeed by python for some reason.&#34;&#34;&#34;
        self.close()

    def close(self):
        &#34;&#34;&#34;Close this window.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        if self.after_id is not None:
            self.root.after_cancel(self.after_id)
            self.after_id = None
        if self.root is not None:
            self.root.destroy()
            self.root = None

    def message(self, message):
        &#34;&#34;&#34;Display a message in a box and wait for the user to click somewhere.

        Args:
            message (str): the string to print

        Returns:
            bool: True if the user triggered a normal event, False if the user
                closed the window abruptly.
        &#34;&#34;&#34;
        # private: the user clicked in the box
        def _c(event):
            self.eventq.put(&#34;ok&#34;)
            self.root.quit()

        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)
        m = tk.Message(
                self.root, text=message,
                padx=20, pady=20,
                relief=tk.RAISED, borderwidth=5,
                )
        # mouse click:
        m.bind(&#34;&lt;Button-1&gt;&#34;, _c)
        # m.grid(row=0, column=0)
        m.place(relx=0.5, rely=0.5, anchor=tk.CENTER)
        while True:
            s = self.wait_event()
            if s[0] == &#34;END&#34;:
                # the window has been closed
                # put the end msg back in the queue and return False
                self.eventq.put(s)
                return False
            # all the other events just close the message box and return True:
            m.destroy()
            return True

    ###########################################################################
    # HIGH LEVEL INTERFACE                                                    #
    # This function can be used to print whole standard boards.               #
    # Matrices should contain integers (-&gt; representing pieces colors/players)#
    # or the None special value (-&gt; nothing there)                            #
    ###########################################################################

    # by default define those 10 colors:
    DEFAULT_COLOR = [&#34;black&#34;, &#34;white&#34;, &#34;red&#34;, &#34;green&#34;, &#34;blue&#34;,
                     &#34;yellow&#34;, &#34;cyan&#34;, &#34;magenta&#34;, &#34;orange&#34;, &#34;darkgrey&#34;]
    &#34;&#34;&#34;A list of ten colors (str) used for ten players identified by numbers.&#34;&#34;&#34;

    def draw_grid(
        self, matrix=None, grid=True
    ):
        &#34;&#34;&#34;Print a complete grid of pieces, using the 10 default colors.

        Args:
            matrix (list of list of int): the players pieces matrix, of the
                specified size. If matrix is None (default), just ignores it.
            grid (boolean): if True (default) draws a horizontal+vertical grid
                to separate the tiles.

        Returns:
            list of int: the graphical objects that were created for the pieces
                (grid excluded).
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)
        # erase everything for a start
        self.delete(tk.ALL)
        # gap is used by draw_tile to fill the inside of a tile (including
        # borders, or not
        if grid:
            for i in range(self.size[0]+self.gap):
                self.create_line(1, i*self.pixels+1,
                                 self.size[1]*self.pixels+1, i*self.pixels+1,
                                 width=1)
            for i in range(self.size[1]+self.gap):
                self.create_line(i*self.pixels+1, 1,
                                 i*self.pixels+1,
                                 self.size[0]*self.pixels+1+self.gap,
                                 width=1)
        # draw the pieces
        o = []
        if matrix is not None:
            for i in range(self.size[0]):
                for j in range(self.size[1]):
                    if matrix[i][j] is not None:
                        o.append(self.draw_piece((i, j), matrix[i][j],
                                 refresh=False))
        # update just once at the end, for performance
        self.update()
        return o

    def erase(
        self
    ):
        &#34;&#34;&#34;Erase everything from the window.

        All graphical objects that were created are deleted.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)
        self.delete(tk.ALL)
        # redraw the grid if it was there:
        if self.gap == 1:
            self.draw_grid()

    ###########################################################################
    # INTERMEDIATE LEVEL INTERFACE                                            #
    # draw various objects on a board (2D grid)                               #
    ###########################################################################
    def draw_piece(
        self, p, player=0,
        color=None,
        refresh=True
    ):
        &#34;&#34;&#34;Draw a piece in position p=(line, column), player-colored.

        Usage notice: don&#39;t use this function if your tiles are too small, you
        won&#39;t see the piece.

        Args:
            p ([int, int]): a couple (line, column) specifying the grid
                position. (0, 0) = top-left position.
            player (int, optional): player number (default: 0)
                player is used only if color is NOT given.
            color (str, optional): fill color of the piece. If a color is
                given, player is ignored.
            refresh (bool): refresh the window after drawing (default: True)

        Returns:
            int: the ID of the graphical object (circle) that was created.
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)
        if color is None:
            if isinstance(player, int):
                color = self.DEFAULT_COLOR[player % len(self.DEFAULT_COLOR)]
            else:
                color = self.DEFAULT_COLOR[0]

        bord = self.pixels//10+1
        i, j = p
        if not (0 &lt;= i &lt; self.size[0] and 0 &lt;= j &lt; self.size[1]):
            raise ValueError(&#34;trying to draw outside the window!&#34;)

        o = self.create_oval(j*self.pixels+bord+1,
                             i*self.pixels+bord+1,
                             (j+1)*self.pixels-bord+1,
                             (i+1)*self.pixels-bord+1,
                             width=1, fill=color)
        if refresh:
            self.update()
        return o

    def move_piece(
        self, obj, pos, refresh=True
    ):
        &#34;&#34;&#34;Move a piece (obj ID) in grid position pos (couple).

        Args:
            obj (int): a previously created piece ID
            pos ([int, int]): new grid position, a couple (line, column)
            refresh (bool, optional): refresh the window after drawing
                (default: True)

        Returns:
            None
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        i, j = pos
        if not (0 &lt;= i &lt; self.size[0] and 0 &lt;= j &lt; self.size[1]):
            raise ValueError(&#34;trying to move a piece outside the window!&#34;)
        bord = self.pixels//10+1
        self.coords(
            obj,
            j*self.pixels+bord+1,
            i*self.pixels+bord+1,
            (j+1)*self.pixels-bord+1,
            (i+1)*self.pixels-bord+1
            )
        if refresh:
            self.update()

    def draw_tile(
        self, p,
        color=&#34;black&#34;,
        border=0,
        refresh=True
    ):
        &#34;&#34;&#34;Fill the inside of a tile in position p=(line, column) with a color.

        Args:
            p ([int, int]): grid position (line, column)
            color (str, optional): color of the tile (default: &#34;black&#34;)
            border (int, optional): border thickness (default: 0) - borders may
                overlap over neighboring tiles
            refresh (bool): refresh the window after drawing (default: True)

        Returns:
            int: the ID of the colored tile
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        i, j = p
        if not (0 &lt;= i &lt; self.size[0] and 0 &lt;= j &lt; self.size[1]):
            raise ValueError(&#34;trying to fill a tile outside the window!&#34;)

        o = self.create_rectangle(j*self.pixels+1+self.gap,
                                  i*self.pixels+1+self.gap,
                                  (j+1)*self.pixels+1,
                                  (i+1)*self.pixels+1,
                                  width=border, fill=color)
        if refresh:
            self.update()
        return o

    def move_tile(
        self, obj, pos, refresh=True
    ):
        &#34;&#34;&#34;Move a colored tile to another grid position.

        Args:
            obj (int): a previously created tile ID
            pos ([int, int]): new position in the grid (line, column)
            refresh (bool, optional): refresh the window after drawing
                (default: True)

        Returns:
            None
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        i, j = pos
        if not (0 &lt;= i &lt; self.size[0] and 0 &lt;= j &lt; self.size[1]):
            raise ValueError(&#34;trying to move a tile outside the window!&#34;)
        self.coords(
            obj,
            j*self.pixels+1++self.gap,
            i*self.pixels+1++self.gap,
            (j+1)*self.pixels+1,
            (i+1)*self.pixels+1
            )
        if refresh:
            self.update()

    ###########################################################################
    # low level interface:                                                    #
    # draw pixels, lines, circles, etc.                                       #
    ###########################################################################
    def draw_line(
        self, x1, x2, color=&#34;black&#34;, thickness=1, refresh=True
    ):
        &#34;&#34;&#34;Draw a line between x1=(l1, c1) and x2=(l2, c2) (excluded).

        Args:
            x1 ([int, int]): pixel-wise positions (line, column) of the first
                point. (0,0) = top-left position.
            x2 ([int, int]): pixel-wise positions (line, column) of the second
                point, excluded.
            color (str, optional): line color (default: &#34;black&#34;)
            thickness (int, optional): thickness of the line (default: 1)
            refresh (bool, optional): refresh the window after drawing
                (default: True)

        Returns:
            int: the ID of the graphical object that was created.
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        o = self.create_line(x1[1]+1, x1[0]+1, x2[1], x2[0],
                             width=thickness, fill=color)
        if refresh:
            self.update()
        return o

    def draw_circle(
        self, x1, x2,
        color=&#34;black&#34;, border=1, refresh=True
    ):
        &#34;&#34;&#34;Draw a circle in the bounding box of x1=(l1,c1) and x2 (excluded).

        Args:
            x1 ([int, int]): pixel-wise positions (line, column) of the first
                point. (0,0) = top-left position.
            x2 ([int, int]): pixel-wise positions (line, column) of the second
                point, excluded.
            color (str, optional): color of the inside (default: &#34;black&#34;)
                       if color == None, don&#39;t fill the circle.
            border (int, optional): border thickness (default: 1) - borders can
                overflow over the given pixels coordinates
            refresh (bool, optional): refresh the window after drawing
                (default: True)

        Returns:
            int: the ID of the graphical object that was created.
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        o = self.create_oval(x1[1]+1, x1[0]+1, x2[1], x2[0],
                             width=border, fill=color)
        if refresh:
            self.update()
        return o

    def draw_text(
        self, position, text,
        color=&#34;black&#34;, fontname=&#34;Purisa&#34;, fontsize=11, refresh=True
    ):
        &#34;&#34;&#34;Draw a text centered at a given position=(line, column).

        Args:
            position ([int, int]): pixel-wise position (line, column).
                (0,0) = top-left position.
            text (str): text to print
            color (str, optional): text color (default: &#34;black&#34;)
            fontname (str, optional): font name (default: &#34;Purisa&#34;)
            fontsize (int, optional): font size (default: 11pt)
            refresh (bool, optional): refresh the window after drawing
                (default: True)

        Returns:
            int: the ID of the graphical object that was created.
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        o = self.create_text(position[1]+1, position[0]+1,
                             text=text,
                             font=(fontname, fontsize),
                             fill=color)
        if refresh:
            self.update()
        return o

    def bg(
        self, obj, before=1, refresh=True
    ):
        &#34;&#34;&#34;Send a graphical object (ID) to the background.

        Args:
            obj (int): object ID returned by an object creation method
            before (int, optional): the object behind which to hide (default:
                1 = all)
            refresh (bool, optional): refresh the window after drawing
                (default: True)

        Returns:
            None
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)
        # se met en fond, derriÃ¨re l&#39;objet &#39;before&#39;:
        self.tag_lower(obj, before)
        if refresh:
            self.update()

    def refresh(
        self
    ):
        &#34;&#34;&#34;Refresh all objects previously drawn in the window.

        Note:
            You can create several successive objects without refreshing by
                passing the extra argument &#34;refresh=False&#34; to the drawing
                functions, and then refresh only once using this function.
                Good for speed, especially if you draw many things.

        Args:
            None

        Returns:
            None
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        self.update()

    def rm(
        self, obj, refresh=True
    ):
        &#34;&#34;&#34;Delete a graphical object (ID).

        Args:
            obj (int): an object ID (returned by an object creation method)
            refresh (bool, optional): refresh the window after drawing
                (default: True)

        Returns:
            None
        &#34;&#34;&#34;
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)

        self.delete(obj)
        if refresh:
            self.update()

    ###########################################################################
    # Main I/O function                                                       #
    ###########################################################################
    def wait_event(self, delay=None):
        &#34;&#34;&#34;Wait for the user to interact with the window.

        The tracked events are only keypress and mouse click (left button).

        Args:
            delay (int, optional): waiting time in ms (default: wait forever)

        Returns:
            If the delay expires (when given)

            - `None`

            Else, returns a couple, the first element being always a string:

            - `(&#34;click&#34;, (line, column))`

                if the user clicks on a tile of the board, where (line, column)
                    are the integer coordinates of the clicked tile

            - `(&#34;key&#34;, letter)`

                if the user hits a key, where letter is a string containing a
                    description of the key. If you&#39;re looking for a specific
                    key, you can give a try to the demo - running
                    `&#39;python3 -m tkdraw&#39;` will print all occuring events in the
                    console

            - `(&#34;END&#34;, None)`

                if the user closes the window
        &#34;&#34;&#34;
        # private: called when the timer expires
        def delay_expire():
            self.eventq.put(None)
            self.idd = None
            self.root.quit()

        # trigger the timer
        self.idd = None
        if delay is not None:
            if not self.root:
                raise InterruptedError(&#34;window killed&#34;)
            self.idd = self.root.after(delay, delay_expire)
        # This is Tk&#39;s main loop
        # checks the events and get out if something happens
        while True:
            ####################
            try:
                # get something from the event queue
                r = self.eventq.get(False)
                # cancels the timer if I got something
                if self.idd is not None and self.root is not None:
                    self.root.after_cancel(self.idd)
                return r
            except queue.Empty:
                # no event in the queue, continue waiting (go to mainloop)
                pass
            ####################
            if not self.root:
                raise InterruptedError(&#34;window killed&#34;)
            # back to the mainloop, it will stop if I get an event
            self.root.mainloop()
            ####################

    def mouse_position(self):
        &#34;&#34;&#34;Return the mouse position (pixel-wise).

        Note:
            The returned coordinates can be negative or greater than the window
                size, when the mouse is out of the window but the window still
                selected.

        Args:
            None

        Returns:
        - a couple ([int, int]): pixel-wise position (line, column) relative to
          (0,0) = top-left position in the window.
        &#34;&#34;&#34;
        # private: the mouse moved
        def _motion(event):
            self.souris = (event.y, event.x)

        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)
        self.refresh()
        try:
            return self.souris
        except AttributeError:
            self.bind(&#34;&lt;Motion&gt;&#34;, _motion)
            self.souris = (0, 0)  # initial position if the mouse doesn&#39;t move
            return self.souris</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>tkinter.Canvas</li>
<li>tkinter.Widget</li>
<li>tkinter.BaseWidget</li>
<li>tkinter.Misc</li>
<li>tkinter.Pack</li>
<li>tkinter.Place</li>
<li>tkinter.Grid</li>
<li>tkinter.XView</li>
<li>tkinter.YView</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="tkdraw.screen.open.DEFAULT_COLOR"><code class="name">var <span class="ident">DEFAULT_COLOR</span></code></dt>
<dd>
<div class="desc"><p>A list of ten colors (str) used for ten players identified by numbers.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tkdraw.screen.open.bg"><code class="name flex">
<span>def <span class="ident">bg</span></span>(<span>self, obj, before=1, refresh=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Send a graphical object (ID) to the background.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>int</code></dt>
<dd>object ID returned by an object creation method</dd>
<dt><strong><code>before</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>the object behind which to hide (default:
1 = all)</dd>
<dt><strong><code>refresh</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>refresh the window after drawing
(default: True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bg(
    self, obj, before=1, refresh=True
):
    &#34;&#34;&#34;Send a graphical object (ID) to the background.

    Args:
        obj (int): object ID returned by an object creation method
        before (int, optional): the object behind which to hide (default:
            1 = all)
        refresh (bool, optional): refresh the window after drawing
            (default: True)

    Returns:
        None
    &#34;&#34;&#34;
    if not self.root:
        raise InterruptedError(&#34;window killed&#34;)
    # se met en fond, derriÃ¨re l&#39;objet &#39;before&#39;:
    self.tag_lower(obj, before)
    if refresh:
        self.update()</code></pre>
</details>
</dd>
<dt id="tkdraw.screen.open.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close this window.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;Close this window.

    Args:
        None

    Returns:
        None
    &#34;&#34;&#34;
    if self.after_id is not None:
        self.root.after_cancel(self.after_id)
        self.after_id = None
    if self.root is not None:
        self.root.destroy()
        self.root = None</code></pre>
</details>
</dd>
<dt id="tkdraw.screen.open.draw_circle"><code class="name flex">
<span>def <span class="ident">draw_circle</span></span>(<span>self, x1, x2, color='black', border=1, refresh=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a circle in the bounding box of x1=(l1,c1) and x2 (excluded).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>[int, int]</code></dt>
<dd>pixel-wise positions (line, column) of the first
point. (0,0) = top-left position.</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>[int, int]</code></dt>
<dd>pixel-wise positions (line, column) of the second
point, excluded.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>color of the inside (default: "black")
if color == None, don't fill the circle.</dd>
<dt><strong><code>border</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>border thickness (default: 1) - borders can
overflow over the given pixels coordinates</dd>
<dt><strong><code>refresh</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>refresh the window after drawing
(default: True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the ID of the graphical object that was created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_circle(
    self, x1, x2,
    color=&#34;black&#34;, border=1, refresh=True
):
    &#34;&#34;&#34;Draw a circle in the bounding box of x1=(l1,c1) and x2 (excluded).

    Args:
        x1 ([int, int]): pixel-wise positions (line, column) of the first
            point. (0,0) = top-left position.
        x2 ([int, int]): pixel-wise positions (line, column) of the second
            point, excluded.
        color (str, optional): color of the inside (default: &#34;black&#34;)
                   if color == None, don&#39;t fill the circle.
        border (int, optional): border thickness (default: 1) - borders can
            overflow over the given pixels coordinates
        refresh (bool, optional): refresh the window after drawing
            (default: True)

    Returns:
        int: the ID of the graphical object that was created.
    &#34;&#34;&#34;
    if not self.root:
        raise InterruptedError(&#34;window killed&#34;)

    o = self.create_oval(x1[1]+1, x1[0]+1, x2[1], x2[0],
                         width=border, fill=color)
    if refresh:
        self.update()
    return o</code></pre>
</details>
</dd>
<dt id="tkdraw.screen.open.draw_grid"><code class="name flex">
<span>def <span class="ident">draw_grid</span></span>(<span>self, matrix=None, grid=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Print a complete grid of pieces, using the 10 default colors.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>matrix</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>int</code></dt>
<dd>the players pieces matrix, of the
specified size. If matrix is None (default), just ignores it.</dd>
<dt><strong><code>grid</code></strong> :&ensp;<code>boolean</code></dt>
<dd>if True (default) draws a horizontal+vertical grid
to separate the tiles.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code> of <code>int</code></dt>
<dd>the graphical objects that were created for the pieces
(grid excluded).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_grid(
    self, matrix=None, grid=True
):
    &#34;&#34;&#34;Print a complete grid of pieces, using the 10 default colors.

    Args:
        matrix (list of list of int): the players pieces matrix, of the
            specified size. If matrix is None (default), just ignores it.
        grid (boolean): if True (default) draws a horizontal+vertical grid
            to separate the tiles.

    Returns:
        list of int: the graphical objects that were created for the pieces
            (grid excluded).
    &#34;&#34;&#34;
    if not self.root:
        raise InterruptedError(&#34;window killed&#34;)
    # erase everything for a start
    self.delete(tk.ALL)
    # gap is used by draw_tile to fill the inside of a tile (including
    # borders, or not
    if grid:
        for i in range(self.size[0]+self.gap):
            self.create_line(1, i*self.pixels+1,
                             self.size[1]*self.pixels+1, i*self.pixels+1,
                             width=1)
        for i in range(self.size[1]+self.gap):
            self.create_line(i*self.pixels+1, 1,
                             i*self.pixels+1,
                             self.size[0]*self.pixels+1+self.gap,
                             width=1)
    # draw the pieces
    o = []
    if matrix is not None:
        for i in range(self.size[0]):
            for j in range(self.size[1]):
                if matrix[i][j] is not None:
                    o.append(self.draw_piece((i, j), matrix[i][j],
                             refresh=False))
    # update just once at the end, for performance
    self.update()
    return o</code></pre>
</details>
</dd>
<dt id="tkdraw.screen.open.draw_line"><code class="name flex">
<span>def <span class="ident">draw_line</span></span>(<span>self, x1, x2, color='black', thickness=1, refresh=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a line between x1=(l1, c1) and x2=(l2, c2) (excluded).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x1</code></strong> :&ensp;<code>[int, int]</code></dt>
<dd>pixel-wise positions (line, column) of the first
point. (0,0) = top-left position.</dd>
<dt><strong><code>x2</code></strong> :&ensp;<code>[int, int]</code></dt>
<dd>pixel-wise positions (line, column) of the second
point, excluded.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>line color (default: "black")</dd>
<dt><strong><code>thickness</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>thickness of the line (default: 1)</dd>
<dt><strong><code>refresh</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>refresh the window after drawing
(default: True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the ID of the graphical object that was created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_line(
    self, x1, x2, color=&#34;black&#34;, thickness=1, refresh=True
):
    &#34;&#34;&#34;Draw a line between x1=(l1, c1) and x2=(l2, c2) (excluded).

    Args:
        x1 ([int, int]): pixel-wise positions (line, column) of the first
            point. (0,0) = top-left position.
        x2 ([int, int]): pixel-wise positions (line, column) of the second
            point, excluded.
        color (str, optional): line color (default: &#34;black&#34;)
        thickness (int, optional): thickness of the line (default: 1)
        refresh (bool, optional): refresh the window after drawing
            (default: True)

    Returns:
        int: the ID of the graphical object that was created.
    &#34;&#34;&#34;
    if not self.root:
        raise InterruptedError(&#34;window killed&#34;)

    o = self.create_line(x1[1]+1, x1[0]+1, x2[1], x2[0],
                         width=thickness, fill=color)
    if refresh:
        self.update()
    return o</code></pre>
</details>
</dd>
<dt id="tkdraw.screen.open.draw_piece"><code class="name flex">
<span>def <span class="ident">draw_piece</span></span>(<span>self, p, player=0, color=None, refresh=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a piece in position p=(line, column), player-colored.</p>
<p>Usage notice: don't use this function if your tiles are too small, you
won't see the piece.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code>[int, int]</code></dt>
<dd>a couple (line, column) specifying the grid
position. (0, 0) = top-left position.</dd>
<dt><strong><code>player</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>player number (default: 0)
player is used only if color is NOT given.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>fill color of the piece. If a color is
given, player is ignored.</dd>
<dt><strong><code>refresh</code></strong> :&ensp;<code>bool</code></dt>
<dd>refresh the window after drawing (default: True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the ID of the graphical object (circle) that was created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_piece(
    self, p, player=0,
    color=None,
    refresh=True
):
    &#34;&#34;&#34;Draw a piece in position p=(line, column), player-colored.

    Usage notice: don&#39;t use this function if your tiles are too small, you
    won&#39;t see the piece.

    Args:
        p ([int, int]): a couple (line, column) specifying the grid
            position. (0, 0) = top-left position.
        player (int, optional): player number (default: 0)
            player is used only if color is NOT given.
        color (str, optional): fill color of the piece. If a color is
            given, player is ignored.
        refresh (bool): refresh the window after drawing (default: True)

    Returns:
        int: the ID of the graphical object (circle) that was created.
    &#34;&#34;&#34;
    if not self.root:
        raise InterruptedError(&#34;window killed&#34;)
    if color is None:
        if isinstance(player, int):
            color = self.DEFAULT_COLOR[player % len(self.DEFAULT_COLOR)]
        else:
            color = self.DEFAULT_COLOR[0]

    bord = self.pixels//10+1
    i, j = p
    if not (0 &lt;= i &lt; self.size[0] and 0 &lt;= j &lt; self.size[1]):
        raise ValueError(&#34;trying to draw outside the window!&#34;)

    o = self.create_oval(j*self.pixels+bord+1,
                         i*self.pixels+bord+1,
                         (j+1)*self.pixels-bord+1,
                         (i+1)*self.pixels-bord+1,
                         width=1, fill=color)
    if refresh:
        self.update()
    return o</code></pre>
</details>
</dd>
<dt id="tkdraw.screen.open.draw_text"><code class="name flex">
<span>def <span class="ident">draw_text</span></span>(<span>self, position, text, color='black', fontname='Purisa', fontsize=11, refresh=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a text centered at a given position=(line, column).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>position</code></strong> :&ensp;<code>[int, int]</code></dt>
<dd>pixel-wise position (line, column).
(0,0) = top-left position.</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>text to print</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>text color (default: "black")</dd>
<dt><strong><code>fontname</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>font name (default: "Purisa")</dd>
<dt><strong><code>fontsize</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>font size (default: 11pt)</dd>
<dt><strong><code>refresh</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>refresh the window after drawing
(default: True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the ID of the graphical object that was created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_text(
    self, position, text,
    color=&#34;black&#34;, fontname=&#34;Purisa&#34;, fontsize=11, refresh=True
):
    &#34;&#34;&#34;Draw a text centered at a given position=(line, column).

    Args:
        position ([int, int]): pixel-wise position (line, column).
            (0,0) = top-left position.
        text (str): text to print
        color (str, optional): text color (default: &#34;black&#34;)
        fontname (str, optional): font name (default: &#34;Purisa&#34;)
        fontsize (int, optional): font size (default: 11pt)
        refresh (bool, optional): refresh the window after drawing
            (default: True)

    Returns:
        int: the ID of the graphical object that was created.
    &#34;&#34;&#34;
    if not self.root:
        raise InterruptedError(&#34;window killed&#34;)

    o = self.create_text(position[1]+1, position[0]+1,
                         text=text,
                         font=(fontname, fontsize),
                         fill=color)
    if refresh:
        self.update()
    return o</code></pre>
</details>
</dd>
<dt id="tkdraw.screen.open.draw_tile"><code class="name flex">
<span>def <span class="ident">draw_tile</span></span>(<span>self, p, color='black', border=0, refresh=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Fill the inside of a tile in position p=(line, column) with a color.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code>[int, int]</code></dt>
<dd>grid position (line, column)</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>color of the tile (default: "black")</dd>
<dt><strong><code>border</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>border thickness (default: 0) - borders may
overlap over neighboring tiles</dd>
<dt><strong><code>refresh</code></strong> :&ensp;<code>bool</code></dt>
<dd>refresh the window after drawing (default: True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>the ID of the colored tile</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_tile(
    self, p,
    color=&#34;black&#34;,
    border=0,
    refresh=True
):
    &#34;&#34;&#34;Fill the inside of a tile in position p=(line, column) with a color.

    Args:
        p ([int, int]): grid position (line, column)
        color (str, optional): color of the tile (default: &#34;black&#34;)
        border (int, optional): border thickness (default: 0) - borders may
            overlap over neighboring tiles
        refresh (bool): refresh the window after drawing (default: True)

    Returns:
        int: the ID of the colored tile
    &#34;&#34;&#34;
    if not self.root:
        raise InterruptedError(&#34;window killed&#34;)

    i, j = p
    if not (0 &lt;= i &lt; self.size[0] and 0 &lt;= j &lt; self.size[1]):
        raise ValueError(&#34;trying to fill a tile outside the window!&#34;)

    o = self.create_rectangle(j*self.pixels+1+self.gap,
                              i*self.pixels+1+self.gap,
                              (j+1)*self.pixels+1,
                              (i+1)*self.pixels+1,
                              width=border, fill=color)
    if refresh:
        self.update()
    return o</code></pre>
</details>
</dd>
<dt id="tkdraw.screen.open.erase"><code class="name flex">
<span>def <span class="ident">erase</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Erase everything from the window.</p>
<p>All graphical objects that were created are deleted.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def erase(
    self
):
    &#34;&#34;&#34;Erase everything from the window.

    All graphical objects that were created are deleted.

    Args:
        None

    Returns:
        None
    &#34;&#34;&#34;
    if not self.root:
        raise InterruptedError(&#34;window killed&#34;)
    self.delete(tk.ALL)
    # redraw the grid if it was there:
    if self.gap == 1:
        self.draw_grid()</code></pre>
</details>
</dd>
<dt id="tkdraw.screen.open.message"><code class="name flex">
<span>def <span class="ident">message</span></span>(<span>self, message)</span>
</code></dt>
<dd>
<div class="desc"><p>Display a message in a box and wait for the user to click somewhere.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>message</code></strong> :&ensp;<code>str</code></dt>
<dd>the string to print</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the user triggered a normal event, False if the user
closed the window abruptly.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def message(self, message):
    &#34;&#34;&#34;Display a message in a box and wait for the user to click somewhere.

    Args:
        message (str): the string to print

    Returns:
        bool: True if the user triggered a normal event, False if the user
            closed the window abruptly.
    &#34;&#34;&#34;
    # private: the user clicked in the box
    def _c(event):
        self.eventq.put(&#34;ok&#34;)
        self.root.quit()

    if not self.root:
        raise InterruptedError(&#34;window killed&#34;)
    m = tk.Message(
            self.root, text=message,
            padx=20, pady=20,
            relief=tk.RAISED, borderwidth=5,
            )
    # mouse click:
    m.bind(&#34;&lt;Button-1&gt;&#34;, _c)
    # m.grid(row=0, column=0)
    m.place(relx=0.5, rely=0.5, anchor=tk.CENTER)
    while True:
        s = self.wait_event()
        if s[0] == &#34;END&#34;:
            # the window has been closed
            # put the end msg back in the queue and return False
            self.eventq.put(s)
            return False
        # all the other events just close the message box and return True:
        m.destroy()
        return True</code></pre>
</details>
</dd>
<dt id="tkdraw.screen.open.mouse_position"><code class="name flex">
<span>def <span class="ident">mouse_position</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the mouse position (pixel-wise).</p>
<h2 id="note">Note</h2>
<p>The returned coordinates can be negative or greater than the window
size, when the mouse is out of the window but the window still
selected.</p>
<h2 id="args">Args</h2>
<p>None
Returns:
- a couple ([int, int]): pixel-wise position (line, column) relative to
(0,0) = top-left position in the window.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mouse_position(self):
    &#34;&#34;&#34;Return the mouse position (pixel-wise).

    Note:
        The returned coordinates can be negative or greater than the window
            size, when the mouse is out of the window but the window still
            selected.

    Args:
        None

    Returns:
    - a couple ([int, int]): pixel-wise position (line, column) relative to
      (0,0) = top-left position in the window.
    &#34;&#34;&#34;
    # private: the mouse moved
    def _motion(event):
        self.souris = (event.y, event.x)

    if not self.root:
        raise InterruptedError(&#34;window killed&#34;)
    self.refresh()
    try:
        return self.souris
    except AttributeError:
        self.bind(&#34;&lt;Motion&gt;&#34;, _motion)
        self.souris = (0, 0)  # initial position if the mouse doesn&#39;t move
        return self.souris</code></pre>
</details>
</dd>
<dt id="tkdraw.screen.open.move_piece"><code class="name flex">
<span>def <span class="ident">move_piece</span></span>(<span>self, obj, pos, refresh=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Move a piece (obj ID) in grid position pos (couple).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>int</code></dt>
<dd>a previously created piece ID</dd>
<dt><strong><code>pos</code></strong> :&ensp;<code>[int, int]</code></dt>
<dd>new grid position, a couple (line, column)</dd>
<dt><strong><code>refresh</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>refresh the window after drawing
(default: True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_piece(
    self, obj, pos, refresh=True
):
    &#34;&#34;&#34;Move a piece (obj ID) in grid position pos (couple).

    Args:
        obj (int): a previously created piece ID
        pos ([int, int]): new grid position, a couple (line, column)
        refresh (bool, optional): refresh the window after drawing
            (default: True)

    Returns:
        None
    &#34;&#34;&#34;
    if not self.root:
        raise InterruptedError(&#34;window killed&#34;)

    i, j = pos
    if not (0 &lt;= i &lt; self.size[0] and 0 &lt;= j &lt; self.size[1]):
        raise ValueError(&#34;trying to move a piece outside the window!&#34;)
    bord = self.pixels//10+1
    self.coords(
        obj,
        j*self.pixels+bord+1,
        i*self.pixels+bord+1,
        (j+1)*self.pixels-bord+1,
        (i+1)*self.pixels-bord+1
        )
    if refresh:
        self.update()</code></pre>
</details>
</dd>
<dt id="tkdraw.screen.open.move_tile"><code class="name flex">
<span>def <span class="ident">move_tile</span></span>(<span>self, obj, pos, refresh=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Move a colored tile to another grid position.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>int</code></dt>
<dd>a previously created tile ID</dd>
<dt><strong><code>pos</code></strong> :&ensp;<code>[int, int]</code></dt>
<dd>new position in the grid (line, column)</dd>
<dt><strong><code>refresh</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>refresh the window after drawing
(default: True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_tile(
    self, obj, pos, refresh=True
):
    &#34;&#34;&#34;Move a colored tile to another grid position.

    Args:
        obj (int): a previously created tile ID
        pos ([int, int]): new position in the grid (line, column)
        refresh (bool, optional): refresh the window after drawing
            (default: True)

    Returns:
        None
    &#34;&#34;&#34;
    if not self.root:
        raise InterruptedError(&#34;window killed&#34;)

    i, j = pos
    if not (0 &lt;= i &lt; self.size[0] and 0 &lt;= j &lt; self.size[1]):
        raise ValueError(&#34;trying to move a tile outside the window!&#34;)
    self.coords(
        obj,
        j*self.pixels+1++self.gap,
        i*self.pixels+1++self.gap,
        (j+1)*self.pixels+1,
        (i+1)*self.pixels+1
        )
    if refresh:
        self.update()</code></pre>
</details>
</dd>
<dt id="tkdraw.screen.open.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Refresh all objects previously drawn in the window.</p>
<h2 id="note">Note</h2>
<p>You can create several successive objects without refreshing by
passing the extra argument "refresh=False" to the drawing
functions, and then refresh only once using this function.
Good for speed, especially if you draw many things.</p>
<h2 id="args">Args</h2>
<p>None</p>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(
    self
):
    &#34;&#34;&#34;Refresh all objects previously drawn in the window.

    Note:
        You can create several successive objects without refreshing by
            passing the extra argument &#34;refresh=False&#34; to the drawing
            functions, and then refresh only once using this function.
            Good for speed, especially if you draw many things.

    Args:
        None

    Returns:
        None
    &#34;&#34;&#34;
    if not self.root:
        raise InterruptedError(&#34;window killed&#34;)

    self.update()</code></pre>
</details>
</dd>
<dt id="tkdraw.screen.open.rm"><code class="name flex">
<span>def <span class="ident">rm</span></span>(<span>self, obj, refresh=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Delete a graphical object (ID).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>int</code></dt>
<dd>an object ID (returned by an object creation method)</dd>
<dt><strong><code>refresh</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>refresh the window after drawing
(default: True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rm(
    self, obj, refresh=True
):
    &#34;&#34;&#34;Delete a graphical object (ID).

    Args:
        obj (int): an object ID (returned by an object creation method)
        refresh (bool, optional): refresh the window after drawing
            (default: True)

    Returns:
        None
    &#34;&#34;&#34;
    if not self.root:
        raise InterruptedError(&#34;window killed&#34;)

    self.delete(obj)
    if refresh:
        self.update()</code></pre>
</details>
</dd>
<dt id="tkdraw.screen.open.wait_event"><code class="name flex">
<span>def <span class="ident">wait_event</span></span>(<span>self, delay=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Wait for the user to interact with the window.</p>
<p>The tracked events are only keypress and mouse click (left button).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>delay</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>waiting time in ms (default: wait forever)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>If the delay expires (when given)</p>
<ul>
<li><code>None</code></li>
</ul>
<p>Else, returns a couple, the first element being always a string:</p>
<ul>
<li>
<p><code>("click", (line, column))</code></p>
<p>if the user clicks on a tile of the board, where (line, column)
are the integer coordinates of the clicked tile</p>
</li>
<li>
<p><code>("key", letter)</code></p>
<p>if the user hits a key, where letter is a string containing a
description of the key. If you're looking for a specific
key, you can give a try to the demo - running
<code>'python3 -m tkdraw'</code> will print all occuring events in the
console</p>
</li>
<li>
<p><code>("END", None)</code></p>
<p>if the user closes the window</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_event(self, delay=None):
    &#34;&#34;&#34;Wait for the user to interact with the window.

    The tracked events are only keypress and mouse click (left button).

    Args:
        delay (int, optional): waiting time in ms (default: wait forever)

    Returns:
        If the delay expires (when given)

        - `None`

        Else, returns a couple, the first element being always a string:

        - `(&#34;click&#34;, (line, column))`

            if the user clicks on a tile of the board, where (line, column)
                are the integer coordinates of the clicked tile

        - `(&#34;key&#34;, letter)`

            if the user hits a key, where letter is a string containing a
                description of the key. If you&#39;re looking for a specific
                key, you can give a try to the demo - running
                `&#39;python3 -m tkdraw&#39;` will print all occuring events in the
                console

        - `(&#34;END&#34;, None)`

            if the user closes the window
    &#34;&#34;&#34;
    # private: called when the timer expires
    def delay_expire():
        self.eventq.put(None)
        self.idd = None
        self.root.quit()

    # trigger the timer
    self.idd = None
    if delay is not None:
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)
        self.idd = self.root.after(delay, delay_expire)
    # This is Tk&#39;s main loop
    # checks the events and get out if something happens
    while True:
        ####################
        try:
            # get something from the event queue
            r = self.eventq.get(False)
            # cancels the timer if I got something
            if self.idd is not None and self.root is not None:
                self.root.after_cancel(self.idd)
            return r
        except queue.Empty:
            # no event in the queue, continue waiting (go to mainloop)
            pass
        ####################
        if not self.root:
            raise InterruptedError(&#34;window killed&#34;)
        # back to the mainloop, it will stop if I get an event
        self.root.mainloop()
        ####################</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tkdraw" href="index.html">tkdraw</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tkdraw.screen.open" href="#tkdraw.screen.open">open</a></code></h4>
<ul class="two-column">
<li><code><a title="tkdraw.screen.open.DEFAULT_COLOR" href="#tkdraw.screen.open.DEFAULT_COLOR">DEFAULT_COLOR</a></code></li>
<li><code><a title="tkdraw.screen.open.bg" href="#tkdraw.screen.open.bg">bg</a></code></li>
<li><code><a title="tkdraw.screen.open.close" href="#tkdraw.screen.open.close">close</a></code></li>
<li><code><a title="tkdraw.screen.open.draw_circle" href="#tkdraw.screen.open.draw_circle">draw_circle</a></code></li>
<li><code><a title="tkdraw.screen.open.draw_grid" href="#tkdraw.screen.open.draw_grid">draw_grid</a></code></li>
<li><code><a title="tkdraw.screen.open.draw_line" href="#tkdraw.screen.open.draw_line">draw_line</a></code></li>
<li><code><a title="tkdraw.screen.open.draw_piece" href="#tkdraw.screen.open.draw_piece">draw_piece</a></code></li>
<li><code><a title="tkdraw.screen.open.draw_text" href="#tkdraw.screen.open.draw_text">draw_text</a></code></li>
<li><code><a title="tkdraw.screen.open.draw_tile" href="#tkdraw.screen.open.draw_tile">draw_tile</a></code></li>
<li><code><a title="tkdraw.screen.open.erase" href="#tkdraw.screen.open.erase">erase</a></code></li>
<li><code><a title="tkdraw.screen.open.message" href="#tkdraw.screen.open.message">message</a></code></li>
<li><code><a title="tkdraw.screen.open.mouse_position" href="#tkdraw.screen.open.mouse_position">mouse_position</a></code></li>
<li><code><a title="tkdraw.screen.open.move_piece" href="#tkdraw.screen.open.move_piece">move_piece</a></code></li>
<li><code><a title="tkdraw.screen.open.move_tile" href="#tkdraw.screen.open.move_tile">move_tile</a></code></li>
<li><code><a title="tkdraw.screen.open.refresh" href="#tkdraw.screen.open.refresh">refresh</a></code></li>
<li><code><a title="tkdraw.screen.open.rm" href="#tkdraw.screen.open.rm">rm</a></code></li>
<li><code><a title="tkdraw.screen.open.wait_event" href="#tkdraw.screen.open.wait_event">wait_event</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>